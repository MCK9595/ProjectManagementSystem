@using ProjectManagementSystem.Shared.Models.DTOs
@using ProjectManagementSystem.Shared.Client.Services
@inject ITaskService TaskService
@inject ILogger<TaskHierarchySelector> Logger

<div class="task-hierarchy-selector">
    <label for="parent-task-select" class="form-label">è¦ªã‚¿ã‚¹ã‚¯</label>
    <select id="parent-task-select" 
            class="form-select @(HasError ? "is-invalid" : "")" 
            @bind="SelectedParentTaskId" 
            @bind:after="OnParentTaskChanged"
            disabled="@IsLoading">
        <option value="">-- è¦ªã‚¿ã‚¹ã‚¯ã‚’é¸æŠ --</option>
        @if (AvailableParentTasks != null)
        {
            @foreach (var task in AvailableParentTasks)
            {
                <option value="@task.Id">
                    @GetTaskHierarchyDisplay(task)
                </option>
            }
        }
    </select>
    
    @if (HasError)
    {
        <div class="invalid-feedback">
            @ErrorMessage
        </div>
    }
    
    @if (IsLoading)
    {
        <div class="form-text">
            <span class="spinner-border spinner-border-sm me-1"></span>
            åˆ©ç”¨å¯èƒ½ãªè¦ªã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...
        </div>
    }
    else if (SelectedParentTask != null)
    {
        <div class="form-text text-success">
            <i class="bi bi-check-circle me-1"></i>
            é¸æŠã•ã‚ŒãŸè¦ªã‚¿ã‚¹ã‚¯: @SelectedParentTask.Title
        </div>
    }
    else if (!string.IsNullOrEmpty(SelectedParentTaskId))
    {
        <div class="form-text text-muted">
            ã“ã®ã‚¿ã‚¹ã‚¯ã¯ç‹¬ç«‹ã—ãŸã‚¿ã‚¹ã‚¯ã«ãªã‚Šã¾ã™
        </div>
    }
</div>

@code {
    [Parameter] public Guid ProjectId { get; set; }
    [Parameter] public Guid? CurrentTaskId { get; set; }
    [Parameter] public Guid? InitialParentTaskId { get; set; }
    [Parameter] public EventCallback<Guid?> OnParentTaskSelectionChanged { get; set; }
    [Parameter] public bool IsRequired { get; set; } = false;

    private List<TaskDto>? AvailableParentTasks;
    private TaskDto? SelectedParentTask;
    private string SelectedParentTaskId = string.Empty;
    private bool IsLoading = false;
    private bool HasError = false;
    private string ErrorMessage = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        if (InitialParentTaskId.HasValue)
        {
            SelectedParentTaskId = InitialParentTaskId.Value.ToString();
        }
        await LoadAvailableParentTasks();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (InitialParentTaskId.HasValue && SelectedParentTaskId != InitialParentTaskId.Value.ToString())
        {
            SelectedParentTaskId = InitialParentTaskId.Value.ToString();
            await OnParentTaskChanged();
        }
    }

    private async Task LoadAvailableParentTasks()
    {
        IsLoading = true;
        HasError = false;
        ErrorMessage = string.Empty;
        StateHasChanged();

        try
        {
            var allTasks = await TaskService.GetTasksAsync(ProjectId, 1, 100);
            if (allTasks?.Items != null)
            {
                // ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã‚’é™¤å¤–ã—ã€å¾ªç’°å‚ç…§ã‚’é˜²ã
                AvailableParentTasks = allTasks.Items
                    .Where(t => t.Id != CurrentTaskId && !IsDescendantOf(t.Id, CurrentTaskId))
                    .OrderBy(t => t.Title)
                    .ToList();
            }
            else
            {
                AvailableParentTasks = new List<TaskDto>();
            }
        }
        catch (Exception ex)
        {
            HasError = true;
            ErrorMessage = "è¦ªã‚¿ã‚¹ã‚¯ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
            Logger.LogError(ex, "Error loading available parent tasks for project {ProjectId}", ProjectId);
        }
        finally
        {
            IsLoading = false;
            StateHasChanged();
        }
    }

    private async Task OnParentTaskChanged()
    {
        if (string.IsNullOrEmpty(SelectedParentTaskId))
        {
            SelectedParentTask = null;
            await OnParentTaskSelectionChanged.InvokeAsync(null);
        }
        else if (Guid.TryParse(SelectedParentTaskId, out var parentTaskId))
        {
            SelectedParentTask = AvailableParentTasks?.FirstOrDefault(t => t.Id == parentTaskId);
            await OnParentTaskSelectionChanged.InvokeAsync(parentTaskId);
        }
    }

    private bool IsDescendantOf(Guid potentialParentId, Guid? currentTaskId)
    {
        if (!currentTaskId.HasValue || AvailableParentTasks == null)
            return false;

        // ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã®å­å­«ã§ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        var visited = new HashSet<Guid>();
        var queue = new Queue<Guid>();
        queue.Enqueue(currentTaskId.Value);

        while (queue.Count > 0)
        {
            var currentId = queue.Dequeue();
            if (visited.Contains(currentId))
                continue;

            visited.Add(currentId);

            // å­ã‚¿ã‚¹ã‚¯ã‚’æ¤œç´¢
            var childTasks = AvailableParentTasks.Where(t => t.ParentTaskId == currentId);
            foreach (var child in childTasks)
            {
                if (child.Id == potentialParentId)
                    return true;
                queue.Enqueue(child.Id);
            }
        }

        return false;
    }

    private string GetTaskHierarchyDisplay(TaskDto task)
    {
        var indent = GetTaskIndentLevel(task.Id);
        var prefix = new string(' ', indent * 2);
        var statusIcon = GetTaskStatusIcon(task.Status);
        return $"{prefix}{statusIcon} {task.Title}";
    }

    private int GetTaskIndentLevel(Guid taskId)
    {
        if (AvailableParentTasks == null)
            return 0;

        var level = 0;
        var currentTask = AvailableParentTasks.FirstOrDefault(t => t.Id == taskId);
        
        while (currentTask?.ParentTaskId != null)
        {
            level++;
            currentTask = AvailableParentTasks.FirstOrDefault(t => t.Id == currentTask.ParentTaskId);
            if (level > 10) // ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢
                break;
        }

        return level;
    }

    private string GetTaskStatusIcon(string status)
    {
        return status switch
        {
            ProjectManagementSystem.WebApp.Wasm.Client.Constants.TaskStatus.ToDo => "âšª",
            ProjectManagementSystem.WebApp.Wasm.Client.Constants.TaskStatus.InProgress => "ğŸ”„",
            ProjectManagementSystem.WebApp.Wasm.Client.Constants.TaskStatus.InReview => "ğŸ‘€",
            ProjectManagementSystem.WebApp.Wasm.Client.Constants.TaskStatus.Done => "âœ…",
            _ => "âšª"
        };
    }

    public async Task RefreshAsync()
    {
        await LoadAvailableParentTasks();
    }

    public bool Validate()
    {
        if (IsRequired && string.IsNullOrEmpty(SelectedParentTaskId))
        {
            HasError = true;
            ErrorMessage = "è¦ªã‚¿ã‚¹ã‚¯ã®é¸æŠã¯å¿…é ˆã§ã™ã€‚";
            StateHasChanged();
            return false;
        }

        HasError = false;
        ErrorMessage = string.Empty;
        StateHasChanged();
        return true;
    }
}

<style>
    .task-hierarchy-selector {
        width: 100%;
    }

    .task-hierarchy-selector select {
        font-family: 'Consolas', 'Monaco', monospace;
    }

    .task-hierarchy-selector .form-text {
        font-size: 0.875rem;
        margin-top: 0.25rem;
    }

    .task-hierarchy-selector .invalid-feedback {
        display: block;
    }
</style>